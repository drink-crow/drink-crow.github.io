<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Dependent names</title>
      <link href="/Dependent_name/"/>
      <url>/Dependent_name/</url>
      
        <content type="html"><![CDATA[<p>编译下述代码时遇到了第一次遇到的问题  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将boost::geometry中的box转换成自定义的Boundary</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumType = <span class="keyword">double</span>&gt;</span><br><span class="line">    Boundary&lt;NumType, <span class="number">2</span>&gt; <span class="built_in">fromBoost</span>(</span><br><span class="line">        <span class="keyword">const</span> boost::geometry::model::box&lt;boost::geometry::model::point&lt;NumType, <span class="number">2</span>,boost::geometry::cs::cartesian&gt;&gt;&amp; box)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Boundary&lt;NumType, <span class="number">2</span>&gt;(Vec&lt;NumType,<span class="number">2</span>&gt;(box.<span class="built_in">min_corner</span>().get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">min_corner</span>().get&lt;<span class="number">1</span>&gt;()),</span><br><span class="line">            Vec&lt;NumType, <span class="number">2</span>&gt;(box.<span class="built_in">max_corner</span>().get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">max_corner</span>().get&lt;<span class="number">1</span>&gt;()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码在 VS2019 C++17 的标准下能编译过了，但是在 Apple Clang 下检查时，<code>box.min_corner().get&lt;0&gt;()</code> 等函数却报了一个第一次见的错误</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing &#x27;template&#x27; keyword prior to dependent template name &#x27;get&#x27;</span><br></pre></td></tr></table></figure><p>查询了一下，发现是 C++ 模板里面的内容<a href="https://en.cppreference.com/w/cpp/language/dependent_name">Dependent names</a>，内容有不少，大致的概括下就是代码在语法解析时，有时候可以同时表示多种意思，这时候编译器需要手工添加的一些标识来确认需要的是什么意思（特别是在模板中）。例如下面模板代码中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T * t</span><br></pre></td></tr></table></figure><p>如果T是一个类型名，那则声明了一个指针，如果T是一个变量则进行operator*()，所以T是并不是一个明确的声明，这时候就是一个 dependent name，依赖于上下文才能明确表明它是什么。<br>所以一开始的代码要改为  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumType = <span class="keyword">double</span>&gt;</span><br><span class="line">Boundary&lt;NumType, <span class="number">2</span>&gt; <span class="built_in">fromBoost</span>(</span><br><span class="line">    <span class="keyword">const</span> boost::geometry::model::box&lt;boost::geometry::model::point&lt;NumType, <span class="number">2</span>,boost::geometry::cs::cartesian&gt;&gt;&amp; box)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> point = boost::geometry::model::point&lt;NumType, <span class="number">2</span>,boost::geometry::cs::cartesian&gt;;</span><br><span class="line">    <span class="keyword">return</span> Boundary&lt;NumType, <span class="number">2</span>&gt;(Vec&lt;NumType,<span class="number">2</span>&gt;(box.<span class="built_in">min_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">min_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">1</span>&gt;()),</span><br><span class="line">        Vec&lt;NumType, <span class="number">2</span>&gt;(box.<span class="built_in">max_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">max_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">1</span>&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是第一次知道<code>.</code>的和<code>-&gt;</code>操作符后面是可以接<code>template</code>的  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> dependent name </tag>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一个SSH key无法被Github Action使用的问题</title>
      <link href="/GitHub_Action_ssh_key/"/>
      <url>/GitHub_Action_ssh_key/</url>
      
        <content type="html"><![CDATA[<p>在blog切换到<code>Hexo</code>同时使用Github Actions来实现CI/CD时，遇到了一个奇怪的问题。<br>使用下面代码生成的ssh Key无法被Github Actions使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Hexo Deploy Key&quot;</span> -f github-deploy-key -N <span class="string">&quot;namespace&quot;</span></span><br></pre></td></tr></table></figure><p>下面代码生成的Key则可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要保持passphase为空</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;username@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>暂不清除是<code>passphase</code>的问题还是<code>-b -N</code>等参数带来的问题</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Boost.MSM中transition_table和state_flod的容量问题</title>
      <link href="/Boost_msm_transition_table_vector/"/>
      <url>/Boost_msm_transition_table_vector/</url>
      
        <content type="html"><![CDATA[<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><del>示例代码里的<code>struct transition_table : mpl::vector</code>改为继承<code>boost::fusion::vector</code></del><br><del>在C++11的标准下就能解放vector容量上限</del><br><a href="https://www.boost.org/doc/libs/1_78_0/libs/msm/doc/HTML/ch05.html">根据Boost中的解释</a>  </p><blockquote><p>Question: Why do I get a very long compile error when I define more than 20 rows in the transition table?  </p><p>Answer: MSM uses Boost.MPL under the hood and this is the default maximum size. Please define the following 3 macros before including any MSM headers:  </p><pre><code>#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS  #define BOOST_MPL_LIMIT_VECTOR_SIZE 30 // or whatever you need  #define BOOST_MPL_LIMIT_MAP_SIZE 30 // or whatever you need  </code></pre><p>Question: Why do I get this error: ”error C2977: ‘boost::mpl::vector’ : too many template arguments”?  </p><p>Answer: The first possibility is that you defined a transition table as, say, vector17 and have 18 entries. The second is that you have 17 entries and have a composite state. Under the hood, MSM adds a row for every event in the composite transition table. The third one is that you used a mpl::vector without the number of entries but are close to the MPL default of 50 and have a composite, thus pushing you above 50. Then you need mpl/vector60/70….hpp and a mpl/map60/70….hpp  </p><p>Question: Why do I get a very long compile error when I define more than 10 states in a state machine?  </p><p>Answer: MSM uses Boost.Fusion under the hood and this is the default maximum size. Please define the following macro before including any MSM headers:  </p><pre><code>#define FUSION_MAX_VECTOR_SIZE 20 // or whatever you need </code></pre></blockquote><p>在不预定义宏的情况下无法修改。而且哪怕定义了，也是支撑不起大规模的状态机的（需要自己实现mpl/map60等等）  </p><ul><li><del><strong>或许可以用<code>fusion.C++11</code>快速实现？</strong></del><br>仍然需要使用上述宏定义，修改超出预定义的上限(50)后, 会访问例如<code>&quot;boost/mpl/vector/vector90.hpp&quot;</code>目录，不修改Boost工程的情况下无法实现，不利于团队代码协作</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>近来项目里大量的用到了状态机，Boost里面有两个状态机库，一个是<code>StateChart</code>，一个是<code>Meta State Machine</code>。<code>StateChart</code>没怎么了解过，主要用的是MSM。实践下来还是比较好用的，能够比较直观的组织代码和提高稳定性。<br>到后面写得状态机越来越复杂时，发现示例代码里面<code>transition_table</code>所继承的<code>mpl::vector</code>容量非常有限。Boost.MPL是个很早版本的元编程库（C++03年代），这个mpl里的vector能够承载的数量是靠手写模板一个个实现的。<br>查阅了下，MSM的文档里面提到了用了<code>Fusion</code>（另一个Boost模板库，同样的库还有Boost.Hana)来保存表  </p><blockquote><p>State objects are built automatically with the state machine. They will exist until state machine destruction. MSM is using Boost.Fusion behind the hood. This unfortunately means that if you define more than 10 states, you will need to extend the default  </p></blockquote><p>而<code>Fusion::vector</code>中提到  </p><blockquote><p>For C++11 compilers, the variadic function interface has no upper bound.<br>For C++03 compilers, the The variadic form accepts 0 to FUSION_MAX_VECTOR_SIZE elements, where FUSION_MAX_VECTOR_SIZE is a user definable predefined maximum that defaults to 10. Example:  </p></blockquote><p>C++11中扩展了可变参数模板，可以解放以前手动定义n个模板参数的重复劳动。<br>唯一疑惑的是MSM使用了Fusion，示例代码里面却用了旧的mpl库，使用Fusion能够无缝替换</p><h3 id="Updated-2022-01-06"><a href="#Updated-2022-01-06" class="headerlink" title="Updated 2022-01-06"></a>Updated 2022-01-06</h3><p>从<a href="https://www.boost.org/doc/libs/1_78_0/libs/msm/doc/HTML/ch08.html#d0e3355">Boost文档</a>里可以看到<code>MSM.v2</code>推出的时候是<code>Boost 1.44</code>，<a href="https://www.boost.org/users/history/version_1_44_0.html">August 13th, 2010 17:00 GMT</a>，那时候<code>C++11</code>还没正式推出，使用了大量的MPL代码，这部分无法修改。<br>而MPL呢，则更老了, <code>Boost 1.32</code>，时间是<a href="https://www.boost.org/users/history/version_1_32_0.html">November 19th, 2004 12:00 GMT</a>，是<code>c++03</code>的版本<br>这两个库都是在<code>C++11</code>正式推出之前就已经发布了，采用了大量<code>c++03</code>模板元编程代码，有一定的局限性（正上文已经提到过）  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UE4 Gameplay Abilities Plugin</title>
      <link href="/UE4_Gameplay_Abilities_plugin/"/>
      <url>/UE4_Gameplay_Abilities_plugin/</url>
      
        <content type="html"><![CDATA[<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="editor-设置"><a href="#editor-设置" class="headerlink" title="editor 设置"></a>editor 设置</h3><ul><li>插件启用Gameplay Abilities和GameplayTagsEditor</li></ul><h3 id="Native代码设置"><a href="#Native代码设置" class="headerlink" title="Native代码设置"></a>Native代码设置</h3><ul><li>要使用此系统的全部功能，添加”GameplayAbilities”、”GameplayTags”和”GameplayTasks”到项目的”(ProjectName).Build.cs”文件中的 PublicDependencyModuleNames 中。</li><li>继承实现一个<code>UAttributeSet</code>作为属性集</li><li>继承自<code>ACharacter</code>或<code>APown</code>之类的角色文件要同样继承接口<code>IAbilitySystemInterface</code>并添加组件<code>UAbilitySysrtemComponent</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AbilitySystemInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AbilitySystemComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TERRAWANDER_API</span> <span class="title">ACharacterBase</span> :</span> <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 技能系统组件</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadWrite, Category = BaseCharacter)</span><br><span class="line">        UAbilitySystemComponent* AbilitySystemComp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性集</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">        URPGAttributeSet* AttributeSet;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><h3 id="近战攻击例子"><a href="#近战攻击例子" class="headerlink" title="近战攻击例子"></a>近战攻击例子</h3><ul><li>继承<code>ACharacter</code>的类中重写<code>PossessedBy</code>中添加初始化技能的函数，当角色被控制器控制时，该函数会被调用</li><li><code>PossessedBy()</code>-&gt;<code>AddStartupGameplayAbilities()</code>中演示使用<code>GiveAbility()</code>添加技能并放回一个<code>FGameplayAbilitySpecHandle</code>用于触发技能</li><li>input绑定的输入触发使用技能的流程, <code>AbilitySystemComp-&gt;TryActivateAbility(meleeAbilitySpecHandle)</code>演示尝试使用一个技能</li><li>当<code>GameplayAbility</code>对象可以被激活时，进入<code>ActivateAbility</code>事件</li><li><code>CommitAbility</code>将应用CD和消耗，<code>PlayMontageandWait</code>将开始播放绑定动画片段</li><li>Montage播放到一定帧的时候会触发动画通知，动画通知到对应的武器打开碰撞</li><li>当武器碰撞触发时将开始攻击判定流程</li><li>如果判定流程成功————碰撞到的是第一次碰到的敌人等等，制作<code>GamePlayEventData</code>并<code>SentGamePlayEventtoActor()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> GAS </tag>
            
            <tag> Gameplay Abilities </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4 Note</title>
      <link href="/UE4_note/"/>
      <url>/UE4_note/</url>
      
        <content type="html"><![CDATA[<ul><li>Charactor 中开启物理模拟(Simulate Physics)后会使Movement component失效</li></ul><h2 id="UE4-attach-调试流程"><a href="#UE4-attach-调试流程" class="headerlink" title="UE4 attach 调试流程"></a>UE4 attach 调试流程</h2><ol><li>VS IDE中选择的工程配置要和Editor中要一直，鼠标在UE Editor左上角项目名字悬停看弹出的配置信息，一般都是Development</li><li>VS中不用编译，直接attach到UE Editor</li><li>在UE Editor中点编译，多点几次，有时候代码可能会没有热更新上去</li><li>运行时就能命中VS中设置的断点了</li><li>如果还是无法命中代码，尝试在无法命中的地方随便修改下代码，然后再在UE编辑器里编译</li></ol><h2 id="C-读取蓝图类"><a href="#C-读取蓝图类" class="headerlink" title="C++ 读取蓝图类"></a>C++ 读取蓝图类</h2><ul><li>非静态加载</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GameplayAbilityBlueprint&#x27;/Game/Ability/MeleeBase_BP.MeleeBase_BP是在UE Editor中对对应蓝图类右键选择copy reference获得的，还需要强制加上 &quot;_C&quot;后缀</span></span><br><span class="line"><span class="keyword">auto</span> ability = LoadClass&lt;UGameplayAbility&gt;(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;GameplayAbilityBlueprint&#x27;/Game/Ability/MeleeBase_BP.MeleeBase_BP_C&#x27;&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="以C-为基类的蓝图类"><a href="#以C-为基类的蓝图类" class="headerlink" title="以C++为基类的蓝图类"></a>以C++为基类的蓝图类</h2><ul><li>当C++基类发生改变时，切记要把对应得蓝图子类切换下父类再切换回来才能应用到正确的数据</li></ul><h2 id="代码热更新问题"><a href="#代码热更新问题" class="headerlink" title="代码热更新问题"></a>代码热更新问题</h2><p>有很多类别都不能在C++代码编译后与立刻而更新到编辑器，比如Enum，函数返回参数等，在代码接口改变后，推荐关闭编辑器重新编译代码再打开</p>]]></content>
      
      
      <categories>
          
          <category> UE4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Note </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Qt的ModelIndex中增加数据擦除</title>
      <link href="/Qt_ModelIndex_typeerase/"/>
      <url>/Qt_ModelIndex_typeerase/</url>
      
        <content type="html"><![CDATA[<h2 id="Model-View-Framework"><a href="#Model-View-Framework" class="headerlink" title="Model/View Framework"></a>Model/View Framework</h2><p>Qt中的<code>QTableWidget</code>、<code>QListWidget</code>、<code>QTreeWidge</code>等背后都是一套常见的<code>Model/View</code>架构用户分离显示和数据。一般的自定义<code>View/Model</code>都可以通过继承<code>QAbstractItemView</code>和<code>QAbstractItemModel</code>来快速实现。</p><h2 id="ModelIndex"><a href="#ModelIndex" class="headerlink" title="ModelIndex"></a>ModelIndex</h2><p><code>View/Model</code>中通过<code>ModelIndex</code>来索引，<code>ModelIndex</code>中通过<code>row</code>、<code>col</code>和<code>internalPointer</code>来索引到具体的数据。能够适配到绝大分数据结构。<br>但是也存在很大的问题，就在于<code>internalPointer</code>的类型是一个<code>const void *</code>，会丢失原有类型信息，这就要求<code>internalPointer</code>指向统一中数据结构。但是很多时候是无法把要显示的数据的数据结构都做成同一个虚基类（比如是修改不了的不同的外部连接库的类）。<br>通过传入类型擦除后的数据结构的指针，或者建立一个map表来索引<code>internalPointer</code>到具体的类型信息可以解决一部分问题，但是还有一些致命的问题————无法自动释放<code>internalPointer</code>指向类型擦除数据结构或者即使的清空map表，随着时间的迁移，内存占用会越来越庞大，或者引入了非常复杂的自动释放机制。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>解决的办法很简单，将<code>internalPointer</code>的类型从<code>const void *</code>替换为<code>QVariant</code>等即可，以<code>QVariant</code>储存类型擦除后的数据结构，不需要修改任何逻辑。<br>不过这样则需要复制下<code>QAbstractItemView</code>、<code>QAbstractItemModel</code>、<code>ModelIndex</code>的源代码，重新构建下应用<code>QVariant</code>的<code>ModelIndex</code>的<code>Model/View</code>框架。</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QModelIndex </tag>
            
            <tag> type earse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Skia</title>
      <link href="/Compile_Skia/"/>
      <url>/Compile_Skia/</url>
      
        <content type="html"><![CDATA[<p><a href="https://skia.org/">Skia官方网站</a></p><h2 id="Window-10"><a href="#Window-10" class="headerlink" title="Window 10"></a>Window 10</h2><p>  Python 2.7.8<br>  Window 10 1909 (18363.1379)<br>  Window 10 SDK<br>  VS 2019<br>  LLVM 11.0.0</p><ul><li>准备Python2，并且设置Python2的优先级高于Python3(在环境变量里Python2的路径比Python3先出现即可)<br>否则会出现depot_tools错误和编译时ICU生成错误</li><li>拉取部署工具库<br><code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></li><li>拉取Skia仓库<br><code>git clone https://skia.googlesource.com/skia.git</code></li><li>同步需要的第三方库<br><code>cd skia</code><br><code>python2 tools/git-sync-deps</code></li><li>设置VS路径<br>在 bn\BUILDCONFIG.gn 文件中，设置<br><code>win_vc = &lt;VS_Path&gt;</code> 如<br><code>win_vc = &quot;C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC&quot;</code></li><li>生成编译文件<br>  Skia 编译成静态连接库中，会自动设置 Runtime 为 MT，需要手动设置为 MD<br>  Win 32位编译需要在输出文件夹中将 <code>toolchain.ninja</code> 中 <code>rule command</code> 中所有的<br>  <code>cmd.exe /c  C:/Program Files (x86)/Windows Kits/10/bin/SetEnv.cmd /x86 &amp;&amp;</code><br>  去掉，实际上既没有这个脚本，也不需要这个脚本<ul><li>win32 Debug 静态连接 /MDd Angle<br>  <code>bin\gn gen out/Debug --args=&quot;is_debug=true target_cpu=\&quot;x86\&quot; extra_cflags=[\&quot;/MDd\&quot;] clang_win=\&quot;C:/Program Files (x86)/LLVM\&quot; skia_use_angle = true&quot;</code></li><li>win32 Release 静态连接 /MD Angle<br>  <code>bin\gn gen out/Release --args=&quot;is_debug=false target_cpu=\&quot;x86\&quot; extra_cflags=[\&quot;/MD\&quot;] clang_win=\&quot;C:/Program Files (x86)/LLVM\&quot; skia_use_angle = true&quot;</code></li></ul></li><li>编译<br><code>ninja -C &lt;outpath&gt;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Skia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Qt</title>
      <link href="/Qt_compile/"/>
      <url>/Qt_compile/</url>
      
        <content type="html"><![CDATA[<h2 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h2><ul><li>Qt 6.0.1</li><li>Window 10 18363.1316 使用Unicode UTF-8提供全球语言支持</li><li>C/C++ Optimizing Compiler Version 19.28.29336 for x86</li><li>CMake version 3.19.4    <em><strong>CMake 需要大于3.18.3，否则输出Ninja工程文件时无法同时配置debug和release</strong></em></li><li>Python 3.9.1</li><li>ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x64-mingw32]</li><li>perl 5, version 32, subversion 1 (v5.32.1) built for MSWin32-x64-multi-thread</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\Code\qsrc&gt;configure -opensource -confirm-license -prefix C:\Qt\6.0.1\msvc2019 -debug-and-release</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维矩形排样/Rectangle Packing</title>
      <link href="/Rectangle_Packing_Algorithm/"/>
      <url>/Rectangle_Packing_Algorithm/</url>
      
        <content type="html"><![CDATA[<p><em><strong><u>现在的确是没时间研究。先把项目的进度推进了。记录研究过程回过头有时间再看看</u></strong></em></p><p>研究的起因在做图形引擎里的文字绘制功能，准备把字符纹理填充到一张、多张纹理，以减少drawcall。搜索了一番，发现事情并不简单，这个关于空间利用效率的算法有很多应用场所————计算机纹理打包，板材切割，集装箱打包货物等等。</p><p>简单的搜索了下，用中文基本没搜出啥有用的信息，用的关键字————矩形打包算法、排料算法<br>知网找了写有关的，比较新的论文看了下</p><ul><li><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&dbname=CJFDAUTO&filename=DYJE202012011&v=w1jssesbP2jiFm3%25mmd2BrHJJuxe5mFZEgs4YZnsboPjSMgzSr%25mmd2BTqlZ0H%25mmd2Fwwt51KVRCGg">曾晓亮,吴琼,袁旭华.二维矩形件排样问题的自适应多岛遗传算法优化[J].锻压技术,2020,45(12):53-58.</a><br><a href="%E4%BA%8C%E7%BB%B4%E7%9F%A9%E5%BD%A2%E4%BB%B6%E6%8E%92%E6%A0%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%9A%E5%B2%9B%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96_%E6%9B%BE%E6%99%93%E4%BA%AE.pdf">直接下载</a></li></ul><p><em><strong><u>中文基本确定只有知网里没看过的文章值得再看看，搜索引擎的不用浪费时间</u></strong></em></p><p>英文搜索了下，关键字基本可以锁定在<code>packing</code>、<code>nesting</code>。先找了写有关的页面看了下</p><ul><li><a href="https://www.david-colson.com/2020/03/10/exploring-rect-packing.html">David Colson, Exploring rectangle packing algorithms</a><br> 这篇博文的作者的研究动机和我非常像，打包字符的纹理到同一张贴图中</li></ul><p><em><strong><u>英文的没怎么细看，随便搜搜看了下，有用的信息不少，可以花时间搜索细看</u></strong></em></p><h2 id="一步到胃"><a href="#一步到胃" class="headerlink" title="一步到胃"></a>一步到胃</h2><p>知名的C算法库<a href="https://github.com/nothings/stb">stb</a>/<code>stb_rect_pack.h</code>，无私奉献的公共领域许可。<br>看了下介绍，效果不太好。不过现在只需要一个大概能用的就行。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rectangle Packing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS中正则表达式使用例子</title>
      <link href="/VS_regular_expression/"/>
      <url>/VS_regular_expression/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetFlag\((?&lt;var&gt;.*),(?&lt;value&gt;.*)\)</span><br></pre></td></tr></table></figure><p>选择了SetFlag(A,B)中的并以${var}和${value}储存，值得注意的是，无嵌套能力，如果AB的表达式中有逗号，则不能正确的分组</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regular Expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeType中bitmap的buffer的数据顺序</title>
      <link href="/Freetype_bitmap_buffer_order/"/>
      <url>/Freetype_bitmap_buffer_order/</url>
      
        <content type="html"><![CDATA[<p>FreeType的bitmap中的数据顺序和屏幕坐标顺序一致，与OpenGL中texture的数据Y轴反转。第一个数据代表左上角，从左到右处理，最后一个数据代表右下角C++  </p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Freetype </tag>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL中Texture数据的顺序</title>
      <link href="/OpenGL_texture_data_order/"/>
      <url>/OpenGL_texture_data_order/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml">OpenGL4 glTexImage2D</a></p><blockquote><p>The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.</p></blockquote><p>buffer中第一个元素代表左下角，从左到右处理，最后一个元素代表右上角</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL ES </tag>
            
            <tag> OpenGL </tag>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glsl中texture采样的必需设置</title>
      <link href="/glsl_texture_setting/"/>
      <url>/glsl_texture_setting/</url>
      
        <content type="html"><![CDATA[<p>glsl中设置了贴图采样，代码中设置贴图一般需要以下步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexImage2D</span>(...); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置环绕和过滤设置</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动生成mipmap</span></span><br><span class="line"><span class="comment">//glGenerateMipmap(GL_TEXTURE_2D);</span></span><br></pre></td></tr></table></figure><p><code>mipmap</code>和<code>环绕过滤</code>设置至少要有一个，或者<code>glTexImage2D()</code>中设置了mipmap。按照经验，<code>OpenGL</code>，<code>OpenGL ES</code> 中均需要这样设置</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL ES </tag>
            
            <tag> GLSL </tag>
            
            <tag> OpenGL </tag>
            
            <tag> texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GLES中attribute中默认位置</title>
      <link href="/GLES_attribute_default_location/"/>
      <url>/GLES_attribute_default_location/</url>
      
        <content type="html"><![CDATA[<p>gles程序遇到了一个在Windows 10 UHD630 下能正确运行却在 macOS 10.15.7 Iris 645却效果不对的问题。macOS下 OpenGL不能抓帧分析，经过了一番努力才发现了问题所在。</p><p>问题在于vertex shader中有好几个attribute, 在glVertexAttribPointer()按照了声明顺序默认了他们的索引。实际上 macOS 下attribute的默认顺序可能是倒过来了。使用了glGetAttribLocation()获取实际索引后，显示效果就正常了。</p><p>在GL3+的时候习惯了在vs中加上layout强制布局。在GLES中没有layout这回事，习惯性地沿用了以前做法，没想到真的出了问题</p>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL ES </tag>
            
            <tag> Attribute </tag>
            
            <tag> GLSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实现多层布局</title>
      <link href="/Qt_Overlap_UI_with_Layout/"/>
      <url>/Qt_Overlap_UI_with_Layout/</url>
      
        <content type="html"><![CDATA[<h2 id="Question-问题"><a href="#Question-问题" class="headerlink" title="Question / 问题"></a>Question / 问题</h2><p>按照需求，需要在一些底层控件上叠加一些UI。比如底层是CAD的绘制页面或者视频播放页面，上面要放一些Label或者Button。上层需要添加的小空间往往不好直接加在最底层的控件上(底层已经有特殊的布局了)</p><h2 id="Search-研究过程"><a href="#Search-研究过程" class="headerlink" title="Search / 研究过程"></a>Search / 研究过程</h2><p>中英文都搜索了不少页面，大多是下面几种方法</p><ul><li>建立两个控件，最上层设置透明背景，属性设置<code>ToolTip</code>一类来实现<ul><li>属性设置的过程很复杂，先后顺序有特定要求</li><li>跨平台有问题</li></ul></li><li>利用<code>QGridLayout</code>布局，两个控件按先后顺序添加在同一个格子里</li><li>使用<code>QStackLayout</code>。</li><li>使用类似与Popup Menu的方法<ul><li><code>Popup</code>属性的窗口失去焦点后就会自动隐藏</li></ul></li></ul><p>除了特别列出来的问题，这些方法都有一个根本的问题————<u><strong>所有的消息都会被最上层的Widget拦截</strong></u>。例如鼠标指针跨过透明背景点击了底层的控件，消息仍会被最上层的控件拦截。  </p><ul><li>有些热心的开发者指出可以在最顶层的控件安装事件过滤器和转发器来实现消息可以合理的转发到底层。<ul><li>过滤和转发所有的事件会带来巨大的工作量，代码复用性几乎没有</li></ul></li><li>也可以通过直接添加上层控件到父窗口来实现————使用<code>setParent()</code>而不是<code>layout()-&gt;addWidget()</code>。<ul><li>没有布局功能，需要在父类实现<code>resizeEvent()</code>和<code>moveEvent()</code>的转发来手动计算布局</li><li>工作量也比较大，代码复用性也不好</li></ul></li></ul><h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution / 解决方案"></a>Solution / 解决方案</h2><p>最后Qt的官方文档<a href="https://doc.qt.io/qt-6/layout.html">Layout Management</a>给了我启发。示例实现了个Qt没有自带而Java中有的布局<code>CardLayout</code></p><blockquote><p>The <code>CardLayout</code> class is inspired by the Java layout manager of the same name.</p></blockquote><p>其中设置子控件geometry部分的代码可以看到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CardLayout::setGeometry</span><span class="params">(<span class="keyword">const</span> QRect &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLayout::<span class="built_in">setGeometry</span>(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_items.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w = r.<span class="built_in">width</span>() - (m_items.<span class="built_in">count</span>() - <span class="number">1</span>) * <span class="built_in">spacing</span>();</span><br><span class="line">    <span class="keyword">int</span> h = r.<span class="built_in">height</span>() - (m_items.<span class="built_in">count</span>() - <span class="number">1</span>) * <span class="built_in">spacing</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m_items.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        QLayoutItem *o = m_items.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="function">QRect <span class="title">geom</span><span class="params">(r.x() + i * spacing(), r.y() + i * spacing(), w, h)</span></span>;</span><br><span class="line">        o-&gt;<span class="built_in">setGeometry</span>(geom);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最关键的一句是<code>o-&gt;setGeometry(geom);</code>。这表明<code>Layout</code>的本质是自动设置子控件的大小和位置。而我直接利用Qt原有的布局功能来计算每一层控件的大小和位置，再根据计算的结果来手动设置每个控件的大小的位置。不就能优雅地达到目的了吗。</p><p>实现起来比想象中的要更简单。先贴出代码<br><strong>OverlapLayout.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QList&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverlapLayout</span> :</span> <span class="keyword">public</span> QLayout</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OverlapLayout</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">OverlapLayout</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 新增的Item会转发到最后一层layout的addItem()</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>         <span class="title">addItem</span><span class="params">(QLayoutItem* item)</span>     <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QSize        <span class="title">sizeHint</span><span class="params">()</span>               <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QSize        <span class="title">minimumSize</span><span class="params">()</span>            <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>          <span class="title">count</span><span class="params">()</span>                  <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QLayoutItem* <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span>)</span>              <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QLayoutItem* <span class="title">takeAt</span><span class="params">(<span class="keyword">int</span>)</span>                    <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>         <span class="title">setGeometry</span><span class="params">(<span class="keyword">const</span> QRect&amp; rect)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddLayout</span><span class="params">(QLayout*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QList&lt;QLayout*&gt; things;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>OverlapLayout.cpp</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;OverlapLayout.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line"></span><br><span class="line">OverlapLayout::OverlapLayout(QWidget* parent)</span><br><span class="line">    :QLayout(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OverlapLayout::addItem(QLayoutItem* item)</span><br><span class="line">&#123;</span><br><span class="line">    if(!things.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        things.last()-&gt;addItem(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSize OverlapLayout::sizeHint() const</span><br><span class="line">&#123;</span><br><span class="line">    QSize s(0, 0);</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        s = s.expandedTo(e-&gt;sizeHint());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSize OverlapLayout::minimumSize() const</span><br><span class="line">&#123;</span><br><span class="line">    QSize s(0, 0);</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        s = s.expandedTo(e-&gt;minimumSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int OverlapLayout::count() const</span><br><span class="line">&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        num += e-&gt;count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QLayoutItem* OverlapLayout::itemAt(int index) const</span><br><span class="line">&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        next = num + e-&gt;count();</span><br><span class="line">        if (index &lt; next)</span><br><span class="line">        &#123;</span><br><span class="line">            return e-&gt;itemAt(index - num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QLayoutItem* OverlapLayout::takeAt(int index)</span><br><span class="line">&#123;</span><br><span class="line">    invalidate();</span><br><span class="line"></span><br><span class="line">    int num = 0;</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        next = num + e-&gt;count();</span><br><span class="line">        if (index &lt; next)</span><br><span class="line">        &#123;</span><br><span class="line">            e-&gt;invalidate();</span><br><span class="line">            return e-&gt;takeAt(index - num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OverlapLayout::setGeometry(const QRect&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">    if (things.size() == 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        e-&gt;invalidate();</span><br><span class="line">        e-&gt;setGeometry(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OverlapLayout::AddLayout(QLayout* layout)</span><br><span class="line">&#123;</span><br><span class="line">    if(layout)</span><br><span class="line">    &#123;</span><br><span class="line">        invalidate();</span><br><span class="line">        things.append(layout);</span><br><span class="line">        addChildLayout(layout);</span><br><span class="line">        layout-&gt;invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的思路也非常简单。储存多层<code>QLayout*</code>， 在<code>setGeometry()</code>中直接把整体的<code>QRect</code>传入到每一个层中计算就好。这样就可以优雅的使用添加多层布局和使用Qt中原有的功能。</p><h2 id="Usage-使用方法"><a href="#Usage-使用方法" class="headerlink" title="Usage / 使用方法"></a>Usage / 使用方法</h2><p>使用的方法也非常简单。父窗口的<code>layout</code>设置为<code>OverlapLayout</code>对象，把每一层的布局设置好，按顺序使用<code>OverlapLayout::AddLayout()</code>添加到多层布局里就好</p><h2 id="Doubts-疑点"><a href="#Doubts-疑点" class="headerlink" title="Doubts / 疑点"></a>Doubts / 疑点</h2><p>目前存在的一个疑问是————如何保证每一层的顺序呢。从官方例子中的<code>CardLayout::setGeometry</code>中看到的表现是，最后设置geometry的<code>QLayoutItem</code>在最上层，在<code>OverlapLayout</code>实际体验中也是如此表现，但是目前还不确定一定会如此</p><p>使用中发现和层序有关的问题，在<code>QScrollBar</code>第一次触发hover事件的时候，<code>QScrollBar</code>会提到最上面刷新一下，又回到原来的层次，但是有些控件会被挡住。触发下被挡住的控件将恢复正常，且不再出现异常</p><h2 id="Update-1-更新1"><a href="#Update-1-更新1" class="headerlink" title="Update 1 / 更新1"></a>Update 1 / 更新1</h2><p>在使用中发现了控件改变后不能做出有效更新的问题。翻看了<code>QBoxLayout</code>等的源代码后发现里面多处使用到了<code>invalidate()</code>来标记重新计算布局。在源代码中增加其调用后表现正常</p>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> Layout </tag>
            
            <tag> Overlap </tag>
            
            <tag> Multilayer Layout </tag>
            
            <tag> Custom QLayout </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不要在Markdown中进行缩进排版</title>
      <link href="/Markdown_use_hint/"/>
      <url>/Markdown_use_hint/</url>
      
        <content type="html"><![CDATA[<p>Markdown 中没有排版的概念，所有不要试图花费大力气去进行缩进等排版。各个Markdown渲染对缩进表达各不相同。</p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pelican 使用笔记</title>
      <link href="/pelican_use_hint/"/>
      <url>/pelican_use_hint/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.getpelican.com/en/4.5.3/quickstart.html">Pelican官方文档</a></p><ul><li><p>Version：4.5.3</p></li><li><p>python：3.6+</p><p><em>以下命令目录均在Pelican工程目录下</em></p></li><li><p>带主题输出</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pelican content -s pelicanconf.py -t /projects/your-site/themes/our-theme</span></span><br><span class="line">pelican content -s pelicanconf.py -t ./theme</span><br></pre></td></tr></table></figure><ul><li>带主题，忽略缓存和自动重载，监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pelican -l -t THEME --ignore-cache -r</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> THEME指的是主题模板所在</span></span><br><span class="line">pelican -l -t ./theme --ignore-cache -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在edge中需要删除本地缓存才能刷新主题</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Pelican </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Pelican </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL drawcall 边界越界问题</title>
      <link href="/OpenGL_drawcall_out_of_range/"/>
      <url>/OpenGL_drawcall_out_of_range/</url>
      
        <content type="html"><![CDATA[<h2 id="buffer数据时size的大小"><a href="#buffer数据时size的大小" class="headerlink" title="buffer数据时size的大小"></a>buffer数据时size的大小</h2><p>在 OpenGL buffer数据一般都是以const void *加size的C语言风格传递数据。例如下面非常经典的<br><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml">void glBufferData( GLenum target, GLsizeiptr size, const void * data, GLenum usage)</a><br>有下面用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据来源</span></span><br><span class="line">std::vector&lt;<span class="keyword">float</span>&gt; dataContainer &#123;···&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 也就是 dataContainer.size() * sizeof (float)</span></span><br><span class="line">GLsizeiptr size = dataContainer.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">decltype</span> (dataContainer)::value_type);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>* data = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(dataContainer.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure><p>可以看到，这里的<code>size</code>是以字节为单位，而且<code>size</code>的类型为 <code>GLsizeiptr</code> 。</p><h2 id="drawcall时count的大小"><a href="#drawcall时count的大小" class="headerlink" title="drawcall时count的大小"></a>drawcall时count的大小</h2><p>同样是非常经典的<br><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml">void glDrawArrays( GLenum mode, GLint first, GLsizei count);</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">float</span>&gt; dataContainer &#123;···&#125;;</span><br><span class="line">GLsizeiptr size = dataContainer.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">decltype</span> (dataContainer)::value_type);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>* data = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(dataContainer.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">GLuint vbo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(GLfloat), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLsizei counts = size / (<span class="number">2</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(GLfloat));</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_LINES, <span class="number">0</span>, counts);</span><br></pre></td></tr></table></figure><p>此时count中每一个的大小是由<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml">glVertexAttribPointer</a>中的<code>size</code>，<code>type</code>和<code>stride</code>共同决定。如上例中，一个点的大小就是<code>2</code>个<code>float</code>的大小。要绘制完buffer中的所有内容需要<code>size / (2*sizeof(GLfloat))</code>。</p><h2 id="drawcall超出边界时会发生情况"><a href="#drawcall超出边界时会发生情况" class="headerlink" title="drawcall超出边界时会发生情况"></a>drawcall超出边界时会发生情况</h2><p>数组越界是一个比较常见的错误。有些语言会直接抛出异常，如C/C++，有些语言则会直接访问到对应的内容，返回不确定的结果。在OpenGL里，drawcall中的越界——如<code>glDrawArrays()</code>中的<code>first</code>和<code>counts</code>指向的显存段超过当前绑定的vbo则是未定义的行为。（至少我在<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml">OpenGL-Refpages</a>中没看到对应的规范）<br>实际上在具体应用中，同样的越界drawcall在不同显卡和操作系统表现出来的行为也是不一样。应该是由显卡驱动厂商决定越界行为的。</p><ul><li><p>macOS OpenGL ES2.0 Intel Iris Plus 645<br>在macOS下，drawcall越界了后，越界的部分的内存的默认值通常是0，在显存使用量不高的情况下，通常不会绘制出奇怪的内容。也不会引发OpenGL错误。这和Apple下Clang编译器的行为也一致，变量默认值为0</p></li><li><p>Windows OpenGL ES2.0 Intel UHD 630<br>在Windows下drawcall越界同样也不会引发OpenGL错误，但是很容易绘制出奇怪的东西出来。</p></li><li><p><em><strong>Windows Angle</strong></em></p></li><li><p><strong>Windows下使用Angle转译glES到Dx值得特别提一下。使用Angle时，如果drawcall越界了，则会直接跳过，什么效果都没有。用RenderDoc截取帧分析会找不到越界的drawcall，显示上也没有效果。推测可能时Dx引发错误或者Angel内部记录到会有越界行为发生。</strong>*</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenGL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> drawcall </tag>
            
            <tag> out of range </tag>
            
            <tag> Angel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QToolBar增加spacer</title>
      <link href="/QToolBar_add_spacer/"/>
      <url>/QToolBar_add_spacer/</url>
      
        <content type="html"><![CDATA[<p>通过一个空的QWidget设置SizePolicy来代替QSpacerItem</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QWidget* spacer = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line">spacer-&gt;<span class="built_in">setSizePolicy</span>(QSizePolicy::Expanding, SizePolicy::Expanding);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tb = <span class="keyword">new</span> QToolBar;</span><br><span class="line">...</span><br><span class="line">tb-&gt;<span class="built_in">addAction</span>(...);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">tb-&gt;<span class="built_in">addWidget</span>(spacer);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">tb-&gt;<span class="built_in">addAction</span>(...);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Qt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Qt </tag>
            
            <tag> QToolBar </tag>
            
            <tag> spacer </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
