<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>函数包装模板</title>
      <link href="/function_warp_template/"/>
      <url>/function_warp_template/</url>
      
        <content type="html"><![CDATA[<h2 id="普通函数"><a href="#普通函数" class="headerlink" title="普通函数"></a>普通函数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, Fn fn, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_wraper</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*do some thing*/</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fn</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*do some thing*/</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; bye.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRAPER(FUNC) func_wraper<span class="meta-string">&lt;decltype(&amp;FUNC), &amp;FUNC&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_a</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*do some thing*/</span> std::cout&lt;&lt;<span class="string">&quot;func_a(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">WRAPER</span>(func_a)(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hello, func_a(0) <span class="built_in">bye</span>.</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="成员函数"><a href="#成员函数" class="headerlink" title="成员函数"></a>成员函数</h2><p>在函数指针的使用上有区别，还有更多的类型，例如包装成员函数在类外使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> MyClass self;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// declear and use in class</span></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, Fn fn, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">memberfunc_wrap_in_memberfunc</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*do some thing*/</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line"></span><br><span class="line">        (*<span class="keyword">this</span>.*fn)(std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*do some thing*/</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot; bye.&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">memberfunc_a</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/*do some thing*/</span> std::cout&lt;&lt;<span class="string">&quot;memberfunc_a(&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRAPER(FUNC) memberfunc_wrap_in_memberfunc<span class="meta-string">&lt;decltype(&amp;self::FUNC), &amp;self::FUNC&gt;</span></span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wrap_a</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="built_in">WRAPER</span>(memberfunc_a)(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Fn, Fn fn, <span class="keyword">typename</span> ClassA,<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wrap_memberfunc</span><span class="params">(ClassA* A, Args... args)</span></span>&#123;</span><br><span class="line">    <span class="comment">/*do some thing*/</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;hello, &quot;</span>;</span><br><span class="line"></span><br><span class="line">    (*A.*fn)(std::forward&lt;Args&gt;(args)...);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*do some thing*/</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot; bye.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MyClass a;</span><br><span class="line">    a.memberfunc_wrap_in_memberfunc&lt;<span class="built_in"><span class="keyword">void</span></span>(MyClass::*)(<span class="keyword">int</span>), &amp;MyClass::memberfunc_a&gt;(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">1</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    a.<span class="built_in">wrap_a</span>(<span class="built_in"><span class="keyword">int</span></span>(<span class="number">2</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    wrap_memberfunc&lt;<span class="keyword">decltype</span>(&amp;MyClass::memberfunc_a) ,&amp;MyClass::memberfunc_a&gt;(&amp;a, <span class="built_in"><span class="keyword">int</span></span>(<span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hello, memberfunc_a(1) <span class="built_in">bye</span>.</span><br><span class="line">hello, memberfunc_a(2) <span class="built_in">bye</span>.</span><br><span class="line">hello, memberfunc_a(3) <span class="built_in">bye</span>.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在macOS M1 上编译 arm64 qt5.15</title>
      <link href="/compile_qt5_mac_m1/"/>
      <url>/compile_qt5_mac_m1/</url>
      
        <content type="html"><![CDATA[<p>许多库，共享出来的代码在往往存在一定的编译问题，Qt 源代码的问题也很多。不同版本存在不同的问题，建议参考 vcpkg 中编译的流程和需要的补丁。</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>system: macOS 12.4 (21F79)<br>cpu: Apple M1<br>Xcode 13.2.1<br>macOS SDK 12.1  </p><h2 id="使用vcpkg编译安装arm64版"><a href="#使用vcpkg编译安装arm64版" class="headerlink" title="使用vcpkg编译安装arm64版"></a>使用vcpkg编译安装arm64版</h2><p>指令：<code>vcpkg install qt5:arm64-osx</code>, 本次安装的版本为 5.15.4  </p><ul><li>icu<br>目前macOS使用vcpkg安装icu有些问题，没有自动依赖或指出需要的环境，需要手动安装<code>autoconf</code>,<code>automake</code>,<code>autoconf-archive</code>  </li><li>XXX-NOTFOUND<br>编译时qmake command还出现了XXX-NOTFOUND的字段，实质是依赖某个库但是没有正确找到。本次编译过程中出现了 <code>ZSTD-XXX-NOTFOUND</code> 和 <code>LZMA_DEBUG-NOTFOUND</code>, vcpkg 中重新安装<code>zstd</code>和<code>liblzma</code>后解决了问题，推测这两个包应该是被文件加密系统影响没有正确的安装。<span id="more"></span></li><li>OSX_DEPLOYMENT_TARGET<br>使用默认arm64 triplet(arm64-osx)时，系统最小版本会设置为当前macOS SDK的版本(本次编译为12.1)，而qt5.15.4 的最高设置的版本为 10.15, vcpkg 会自动设置为10.15(实际编译提示的好像是11.0), 而 M1 芯片支持的最低操作系统也是11.0 big sur。<br>若直接指定为10.13，则有一个依赖库pcre2会报错 <code>&quot;Must target Big Sur or newer&quot;</code></li><li>Cleaning before build xxx<br>这一步非常慢，但是也不占用cpu、内存、硬盘，需要耐性等待，每次至少30分钟，耐心等待。  </li></ul><h2 id="自行编译"><a href="#自行编译" class="headerlink" title="自行编译"></a>自行编译</h2><p>源代码为Qt在线安装器中的5.15.2<br>尝试使用以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure -prefix /Users/Shared/Qt/5.15.2/macos -release -opensource -nomake tests -confirm-license QMAKE_APPLE_DEVICE_ARCHS=arm64 QMAKE_MACOSX_DEPLOYMENT_TARGET=10.13</span><br><span class="line">make -j16</span><br><span class="line">make install </span><br></pre></td></tr></table></figure><p>其中<code>QMAKE_APPLE_DEVICE_ARCHS=arm64</code>可以指定编译的架构，而<code>QMAKE_MACOSX_DEPLOYMENT_TARGET=10.13</code>则好像无效，观测到vcpkg中是使用设定 macOS SDK 的版本来指定的<br>特别注明 configure 重新配置环境时，需要删除全部缓存才能成功，最保险的办法是配置前保存一份源码的压缩包，每次重新配置都删除旧的文件夹再解压<br>编译失败，代码错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/clang++ -c -pipe -stdlib=libc++ -O2 -std=c++1z  -arch arm64 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk -mmacosx-version-min=10.13 -fvisibility=hidden -fvisibility-inlines-hidden -fno-exceptions -Wall -Wextra -Winconsistent-missing-override -Wobjc-interface-ivars -Wobjc-method-access -Wobjc-multiple-method-names -Werror=unguarded-availability -Werror=unguarded-availability-new -Werror=unsupported-availability-guard -fPIC -DQT_NO_LINKED_LIST -DQT_NO_JAVA_STYLE_ITERATORS -DQT_NO_FOREACH -DQT_DEPRECATED_WARNINGS -DQT_NO_NARROWING_CONVERSIONS_IN_CONNECT -DGL_SILENCE_DEPRECATION -DQT_NO_EXCEPTIONS -D_LARGEFILE64_SOURCE -D_LARGEFILE_SOURCE -DQT_NO_DEBUG -DQT_PLUGIN -DQT_ACCESSIBILITY_SUPPORT_LIB -DQT_THEME_SUPPORT_LIB -DQT_FONTDATABASE_SUPPORT_LIB -DQT_GRAPHICS_SUPPORT_LIB -DQT_CLIPBOARD_SUPPORT_LIB -DQT_PRINTSUPPORT_LIB -DQT_WIDGETS_LIB -DQT_GUI_LIB -DQT_CORE_LIB -I. -I../../../../include -I../../../../include/QtAccessibilitySupport -I../../../../include/QtAccessibilitySupport/5.15.2 -I../../../../include/QtAccessibilitySupport/5.15.2/QtAccessibilitySupport -I../../../../include/QtThemeSupport -I../../../../include/QtThemeSupport/5.15.2 -I../../../../include/QtThemeSupport/5.15.2/QtThemeSupport -I../../../../include/QtFontDatabaseSupport -I../../../../include/QtFontDatabaseSupport/5.15.2 -I../../../../include/QtFontDatabaseSupport/5.15.2/QtFontDatabaseSupport -I../../../../include/QtGraphicsSupport -I../../../../include/QtGraphicsSupport/5.15.2 -I../../../../include/QtGraphicsSupport/5.15.2/QtGraphicsSupport -I../../../../include/QtPrintSupport/5.15.2 -I../../../../include/QtPrintSupport/5.15.2/QtPrintSupport -I../../../../include/QtWidgets/5.15.2 -I../../../../include/QtWidgets/5.15.2/QtWidgets -I../../../../include/QtGui/5.15.2 -I../../../../include/QtGui/5.15.2/QtGui -I../../../../include/QtClipboardSupport -I../../../../include/QtClipboardSupport/5.15.2 -I../../../../include/QtClipboardSupport/5.15.2/QtClipboardSupport -I../../../../include/QtPrintSupport -I../../../../include/QtWidgets -I../../../../include/QtGui -I../../../../include/QtCore/5.15.2 -I../../../../include/QtCore/5.15.2/QtCore -I../../../../include/QtCore -I.moc -I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/System/Library/Frameworks/OpenGL.framework/Headers -I/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX12.1.sdk/System/Library/Frameworks/AGL.framework/Headers -I../../../../mkspecs/macx-clang -F/Users/Mink/Qt/5.15.2/Src/qtbase/lib -o .obj/qprintengine_mac.o qprintengine_mac.mm</span><br><span class="line">In file included from qiosurfacegraphicsbuffer.mm:40:</span><br><span class="line">./qiosurfacegraphicsbuffer.h:54:32: error: unknown <span class="built_in">type</span> name <span class="string">&#x27;CGColorSpaceRef&#x27;</span>; did you mean <span class="string">&#x27;QColorSpace&#x27;</span>?</span><br><span class="line">    void setColorSpace(QCFType&lt;CGColorSpaceRef&gt; colorSpace);</span><br><span class="line">                               ^~~~~~~~~~~~~~~</span><br><span class="line">                               QColorSpace</span><br><span class="line">../../../../include/QtCore/../../src/corelib/kernel/qmetatype.h:2090:1: note: <span class="string">&#x27;QColorSpace&#x27;</span> declared here</span><br><span class="line">QT_FOR_EACH_STATIC_GUI_CLASS(QT_FORWARD_DECLARE_STATIC_TYPES_ITER)</span><br><span class="line">^</span><br><span class="line">../../../../include/QtCore/../../src/corelib/kernel/qmetatype.h:178:24: note: expanded from macro <span class="string">&#x27;QT_FOR_EACH_STATIC_GUI_CLASS&#x27;</span></span><br><span class="line">    F(QColorSpace, 87, QColorSpace) \</span><br><span class="line">                       ^</span><br><span class="line">qiosurfacegraphicsbuffer.mm:90:32: error: out-of-line definition of <span class="string">&#x27;setColorSpace&#x27;</span> does not match any declaration <span class="keyword">in</span> <span class="string">&#x27;QIOSurfaceGraphicsBuffer&#x27;</span></span><br><span class="line">void QIOSurfaceGraphicsBuffer::setColorSpace(QCFType&lt;CGColorSpaceRef&gt; colorSpace)</span><br><span class="line">                               ^~~~~~~~~~~~~</span><br><span class="line">./qiosurfacegraphicsbuffer.h:54:24: note: <span class="built_in">type</span> of 1st parameter of member declaration does not match definition (<span class="string">&#x27;QCFType&lt;QColorSpace&gt;&#x27;</span> vs <span class="string">&#x27;QCFType&lt;CGColorSpaceRef&gt;&#x27;</span>)</span><br><span class="line">    void setColorSpace(QCFType&lt;CGColorSpaceRef&gt; colorSpace);</span><br></pre></td></tr></table></figure><p>更具 vcpkg 中的补丁，该错误需要增加补丁  </p><p>cocoa.patch</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h b/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h</span><br><span class="line">index e070ba97..07c75b04 100644</span><br><span class="line">--- a/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h</span><br><span class="line">+++ b/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h</span><br><span class="line">@@ -40,6 +40,7 @@</span><br><span class="line">diff --git a/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h b/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h</span><br><span class="line">index e070ba97..07c75b04 100644</span><br><span class="line">--- a/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h</span><br><span class="line">+++ b/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h</span><br><span class="line">@@ -40,6 +40,7 @@</span><br><span class="line"> #ifndef QIOSURFACEGRAPHICSBUFFER_H</span><br><span class="line"> #define QIOSURFACEGRAPHICSBUFFER_H</span><br><span class="line"> </span><br><span class="line">+#include &lt;CoreGraphics/CGColorSpace.h&gt;</span><br><span class="line"> #include &lt;qpa/qplatformgraphicsbuffer.h&gt;</span><br><span class="line"> #include &lt;private/qcore_mac_p.h&gt;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是还有不少地方需要打补丁，建议使用或参照 vcpkg 中的流程</p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
            <tag> vcpkg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Enhanced Input 的初始化后无法使用的问题</title>
      <link href="/UE4_EnhancedInput/"/>
      <url>/UE4_EnhancedInput/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>  UE4.27.2 win10 x64 VS2019</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h2><p>  EnhancedInput在首次使用中会失效, 如果是在编辑器中运行, 第二次运行后就可以使用. 在打包的程序, 或以独立窗口运行都会失效. 奇怪的是, 在EnhancedInput失效的时候,是能正常访问EnhancedInput System Interface 的, 而且绑定也没有出问题  </p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法:"></a>解决方法:</h2><p>在角色蓝图中应用 EnhancedInput System Interface, EnhancedInput的代码里写到蓝图里的函数很多都是只有外表接口,没有实际作用的.但是在蓝图里显式引用了下EnhancedInput System Local Player Interface后的确在首次运行了也可以正常使用EnhancedInput了.</p><h2 id="原因"><a href="#原因" class="headerlink" title="原因:"></a>原因:</h2><p>  尚未找到确切原因, 推测是UObject的引用问题, 或者首次运行,在设置了EnhancedInput之后, 引擎有部分逻辑错误又将InputSystem初始化了</p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UObject PostInit 问题</title>
      <link href="/UE4_Object_Init/"/>
      <url>/UE4_Object_Init/</url>
      
        <content type="html"><![CDATA[<p>由于UE4的反射系统，应当慎重把握UObject对象的游戏性初始化时机。例如一个UObject对象，需要创建另一个UObject并持续引用时，则不应再PostInit中创建。这样会导致继承该UObject的蓝图，在保存时会运行一次PostInit，从而试图保存一个动态创建的UObject。<br>从另外一个角度来说，在UE4 editor中，由于代码热加载/编辑器多次运行地图，对象有可能在任何时候进行调用设置的游戏性初始化设置。而一般的设想中，这些游戏性初始化的顺序都是按照编写的逻辑线性运行，而这里由于为了实现编辑器的动态加载功能，有很多初始化将会被多次运行，但UOBject并不是完全重新初始化。所以需要仔细安排进入和退出代码。同时在网络环境，也会出现这种时序不对的问题，所以代码逻辑不能按照一般的线性逻辑去编写</p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多维比较算法</title>
      <link href="/Multi_Dimension_Compare/"/>
      <url>/Multi_Dimension_Compare/</url>
      
        <content type="html"><![CDATA[<p>使用set/map需要一个对储存元素比较大小的算法，很多时候会用上向量、矩阵的储存。一般来说是这样  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vec4</span> &#123;</span></span><br><span class="line">    <span class="keyword">double</span> x,y,z,w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(cosnt vec4&amp; r) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt; r.x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(x &gt; r.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(y &lt; r.y) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(y &gt; r.y) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(z &lt; r.z) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(z &gt; r.z) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(w &lt; r.x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要多次比较，对CPU来说不够友好，特别是通常来说一次查找需要多次比较<br><code>Boost</code>里面给出的方法是<a href="https://www.boost.org/doc/libs/1_76_0/doc/html/hash/reference.html">多次hash</a>，而且不保证严格正确  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> seed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(; first != last; ++first)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">hash_combine</span>(seed, *first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> seed;</span><br></pre></td></tr></table></figure><span id="more"></span><p>自己想了一个算法。大概就是每一个维度，抽象的视为一位数，vec4就是一个4位数，vec5就是一个5位数，而比较大小，则可以两个对象抽象成的两个数字，逐位比较大小，当小于的情况出现比大于早时，就是A小于B。其实和最上面的方法很像，但是不立刻放回，而是储存所有的结果，再一次性比较返回，主要优化的地方在减少了分支预测（未测试）  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">size_t</span> D&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> vec&lt;D&gt;&amp; A, <span class="keyword">const</span> vec&lt;D&gt;&amp; B)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">size_t</span> min = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != D; ++i) <span class="comment">// 由编译器做展开优化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用三元操作符消去分支预测的影响</span></span><br><span class="line">        min = A[i] &lt; B[i] ? min | (<span class="number">1</span> &lt; i) : min;</span><br><span class="line">        max = A[i] &gt; B[i] ? max | (<span class="number">1</span> &lt; i) : max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> min &gt; max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>上面代码未经测试，应该找个时间测试下</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> multi dimension compare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dependent names</title>
      <link href="/Dependent_name/"/>
      <url>/Dependent_name/</url>
      
        <content type="html"><![CDATA[<p>编译下述代码时遇到了第一次遇到的问题  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将boost::geometry中的box转换成自定义的Boundary</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumType = <span class="keyword">double</span>&gt;</span><br><span class="line">    Boundary&lt;NumType, <span class="number">2</span>&gt; <span class="built_in">fromBoost</span>(</span><br><span class="line">        <span class="keyword">const</span> boost::geometry::model::box&lt;boost::geometry::model::point&lt;NumType, <span class="number">2</span>,boost::geometry::cs::cartesian&gt;&gt;&amp; box)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Boundary&lt;NumType, <span class="number">2</span>&gt;(Vec&lt;NumType,<span class="number">2</span>&gt;(box.<span class="built_in">min_corner</span>().get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">min_corner</span>().get&lt;<span class="number">1</span>&gt;()),</span><br><span class="line">            Vec&lt;NumType, <span class="number">2</span>&gt;(box.<span class="built_in">max_corner</span>().get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">max_corner</span>().get&lt;<span class="number">1</span>&gt;()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这段代码在 VS2019 C++17 的标准下能编译过了，但是在 Apple Clang 下检查时，<code>box.min_corner().get&lt;0&gt;()</code> 等函数却报了一个第一次见的错误</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">missing &#x27;template&#x27; keyword prior to dependent template name &#x27;get&#x27;</span><br></pre></td></tr></table></figure><p>查询了一下，发现是 C++ 模板里面的内容<a href="https://en.cppreference.com/w/cpp/language/dependent_name">Dependent names</a>，内容有不少，大致的概括下就是代码在语法解析时，有时候可以同时表示多种意思，这时候编译器需要手工添加的一些标识来确认需要的是什么意思（特别是在模板中）。例如下面模板代码中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T * t</span><br></pre></td></tr></table></figure><p>如果T是一个类型名，那则声明了一个指针，如果T是一个变量则进行operator*()，所以T是并不是一个明确的声明，这时候就是一个 dependent name，依赖于上下文才能明确表明它是什么。<br>所以一开始的代码要改为  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> NumType = <span class="keyword">double</span>&gt;</span><br><span class="line">Boundary&lt;NumType, <span class="number">2</span>&gt; <span class="built_in">fromBoost</span>(</span><br><span class="line">    <span class="keyword">const</span> boost::geometry::model::box&lt;boost::geometry::model::point&lt;NumType, <span class="number">2</span>,boost::geometry::cs::cartesian&gt;&gt;&amp; box)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> point = boost::geometry::model::point&lt;NumType, <span class="number">2</span>,boost::geometry::cs::cartesian&gt;;</span><br><span class="line">    <span class="keyword">return</span> Boundary&lt;NumType, <span class="number">2</span>&gt;(Vec&lt;NumType,<span class="number">2</span>&gt;(box.<span class="built_in">min_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">min_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">1</span>&gt;()),</span><br><span class="line">        Vec&lt;NumType, <span class="number">2</span>&gt;(box.<span class="built_in">max_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">0</span>&gt;(), box.<span class="built_in">max_corner</span>().<span class="keyword">template</span> get&lt;<span class="number">1</span>&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是第一次知道<code>.</code>的和<code>-&gt;</code>操作符后面是可以接<code>template</code>的  </p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> dependent name </tag>
            
            <tag> template </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一个SSH key无法被Github Action使用的问题</title>
      <link href="/GitHub_Action_ssh_key/"/>
      <url>/GitHub_Action_ssh_key/</url>
      
        <content type="html"><![CDATA[<p>在blog切换到<code>Hexo</code>同时使用Github Actions来实现CI/CD时，遇到了一个奇怪的问题。<br>使用下面代码生成的ssh Key无法被Github Actions使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;Hexo Deploy Key&quot;</span> -f github-deploy-key -N <span class="string">&quot;namespace&quot;</span></span><br></pre></td></tr></table></figure><p>下面代码生成的Key则可以</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 要保持passphase为空</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;username@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>暂不清除是<code>passphase</code>的问题还是<code>-b -N</code>等参数带来的问题</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Boost.MSM中transition_table和state_flod的容量问题</title>
      <link href="/Boost_msm_transition_table_vector/"/>
      <url>/Boost_msm_transition_table_vector/</url>
      
        <content type="html"><![CDATA[<h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p><del>示例代码里的<code>struct transition_table : mpl::vector</code>改为继承<code>boost::fusion::vector</code></del><br><del>在C++11的标准下就能解放vector容量上限</del><br><a href="https://www.boost.org/doc/libs/1_78_0/libs/msm/doc/HTML/ch05.html">根据Boost中的解释</a>  </p><blockquote><p>Question: Why do I get a very long compile error when I define more than 20 rows in the transition table?  </p><p>Answer: MSM uses Boost.MPL under the hood and this is the default maximum size. Please define the following 3 macros before including any MSM headers:  </p><pre><code>#define BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS  #define BOOST_MPL_LIMIT_VECTOR_SIZE 30 // or whatever you need  #define BOOST_MPL_LIMIT_MAP_SIZE 30 // or whatever you need  </code></pre><p>Question: Why do I get this error: ”error C2977: ‘boost::mpl::vector’ : too many template arguments”?  </p><p>Answer: The first possibility is that you defined a transition table as, say, vector17 and have 18 entries. The second is that you have 17 entries and have a composite state. Under the hood, MSM adds a row for every event in the composite transition table. The third one is that you used a mpl::vector without the number of entries but are close to the MPL default of 50 and have a composite, thus pushing you above 50. Then you need mpl/vector60/70….hpp and a mpl/map60/70….hpp  </p><p>Question: Why do I get a very long compile error when I define more than 10 states in a state machine?  </p><p>Answer: MSM uses Boost.Fusion under the hood and this is the default maximum size. Please define the following macro before including any MSM headers:  </p><pre><code>#define FUSION_MAX_VECTOR_SIZE 20 // or whatever you need </code></pre></blockquote><p>在不预定义宏的情况下无法修改。而且哪怕定义了，也是支撑不起大规模的状态机的（需要自己实现mpl/map60等等）  </p><span id="more"></span><ul><li><del><strong>或许可以用<code>fusion.C++11</code>快速实现？</strong></del><br>仍然需要使用上述宏定义，修改超出预定义的上限(50)后, 会访问例如<code>&quot;boost/mpl/vector/vector90.hpp&quot;</code>目录，不修改Boost工程的情况下无法实现，不利于团队代码协作</li></ul><h2 id="Analysis"><a href="#Analysis" class="headerlink" title="Analysis"></a>Analysis</h2><p>近来项目里大量的用到了状态机，Boost里面有两个状态机库，一个是<code>StateChart</code>，一个是<code>Meta State Machine</code>。<code>StateChart</code>没怎么了解过，主要用的是MSM。实践下来还是比较好用的，能够比较直观的组织代码和提高稳定性。<br>到后面写得状态机越来越复杂时，发现示例代码里面<code>transition_table</code>所继承的<code>mpl::vector</code>容量非常有限。Boost.MPL是个很早版本的元编程库（C++03年代），这个mpl里的vector能够承载的数量是靠手写模板一个个实现的。<br>查阅了下，MSM的文档里面提到了用了<code>Fusion</code>（另一个Boost模板库，同样的库还有Boost.Hana)来保存表  </p><blockquote><p>State objects are built automatically with the state machine. They will exist until state machine destruction. MSM is using Boost.Fusion behind the hood. This unfortunately means that if you define more than 10 states, you will need to extend the default  </p></blockquote><p>而<code>Fusion::vector</code>中提到  </p><blockquote><p>For C++11 compilers, the variadic function interface has no upper bound.<br>For C++03 compilers, the The variadic form accepts 0 to FUSION_MAX_VECTOR_SIZE elements, where FUSION_MAX_VECTOR_SIZE is a user definable predefined maximum that defaults to 10. Example:  </p></blockquote><p>C++11中扩展了可变参数模板，可以解放以前手动定义n个模板参数的重复劳动。<br>唯一疑惑的是MSM使用了Fusion，示例代码里面却用了旧的mpl库，使用Fusion能够无缝替换</p><h3 id="Updated-2022-01-06"><a href="#Updated-2022-01-06" class="headerlink" title="Updated 2022-01-06"></a>Updated 2022-01-06</h3><p>从<a href="https://www.boost.org/doc/libs/1_78_0/libs/msm/doc/HTML/ch08.html#d0e3355">Boost文档</a>里可以看到<code>MSM.v2</code>推出的时候是<code>Boost 1.44</code>，<a href="https://www.boost.org/users/history/version_1_44_0.html">August 13th, 2010 17:00 GMT</a>，那时候<code>C++11</code>还没正式推出，使用了大量的MPL代码，这部分无法修改。<br>而MPL呢，则更老了, <code>Boost 1.32</code>，时间是<a href="https://www.boost.org/users/history/version_1_32_0.html">November 19th, 2004 12:00 GMT</a>，是<code>c++03</code>的版本<br>这两个库都是在<code>C++11</code>正式推出之前就已经发布了，采用了大量<code>c++03</code>模板元编程代码，有一定的局限性（正上文已经提到过）  </p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UE4 Gameplay Abilities Plugin</title>
      <link href="/UE4_Gameplay_Abilities_plugin/"/>
      <url>/UE4_Gameplay_Abilities_plugin/</url>
      
        <content type="html"><![CDATA[<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><h3 id="editor-设置"><a href="#editor-设置" class="headerlink" title="editor 设置"></a>editor 设置</h3><ul><li>插件启用Gameplay Abilities和GameplayTagsEditor</li></ul><h3 id="Native代码设置"><a href="#Native代码设置" class="headerlink" title="Native代码设置"></a>Native代码设置</h3><ul><li>要使用此系统的全部功能，添加”GameplayAbilities”、”GameplayTags”和”GameplayTasks”到项目的”(ProjectName).Build.cs”文件中的 PublicDependencyModuleNames 中。</li><li>继承实现一个<code>UAttributeSet</code>作为属性集</li><li>继承自<code>ACharacter</code>或<code>APown</code>之类的角色文件要同样继承接口<code>IAbilitySystemInterface</code>并添加组件<code>UAbilitySysrtemComponent</code><span id="more"></span></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AbilitySystemInterface.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;AbilitySystemComponent.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">UCLASS</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TERRAWANDER_API</span> <span class="title">ACharacterBase</span> :</span> <span class="keyword">public</span> ACharacter, <span class="keyword">public</span> IAbilitySystemInterface</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> UAbilitySystemComponent* <span class="title">GetAbilitySystemComponent</span><span class="params">()</span><span class="keyword">const</span></span>;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:    </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 技能系统组件</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>(VisibleAnywhere, BlueprintReadWrite, Category = BaseCharacter)</span><br><span class="line">        UAbilitySystemComponent* AbilitySystemComp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 属性集</span></span><br><span class="line">    <span class="built_in">UPROPERTY</span>()</span><br><span class="line">        URPGAttributeSet* AttributeSet;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><h3 id="近战攻击例子"><a href="#近战攻击例子" class="headerlink" title="近战攻击例子"></a>近战攻击例子</h3><ul><li>继承<code>ACharacter</code>的类中重写<code>PossessedBy</code>中添加初始化技能的函数，当角色被控制器控制时，该函数会被调用</li><li><code>PossessedBy()</code>-&gt;<code>AddStartupGameplayAbilities()</code>中演示使用<code>GiveAbility()</code>添加技能并放回一个<code>FGameplayAbilitySpecHandle</code>用于触发技能</li><li>input绑定的输入触发使用技能的流程, <code>AbilitySystemComp-&gt;TryActivateAbility(meleeAbilitySpecHandle)</code>演示尝试使用一个技能</li><li>当<code>GameplayAbility</code>对象可以被激活时，进入<code>ActivateAbility</code>事件</li><li><code>CommitAbility</code>将应用CD和消耗，<code>PlayMontageandWait</code>将开始播放绑定动画片段</li><li>Montage播放到一定帧的时候会触发动画通知，动画通知到对应的武器打开碰撞</li><li>当武器碰撞触发时将开始攻击判定流程</li><li>如果判定流程成功————碰撞到的是第一次碰到的敌人等等，制作<code>GamePlayEventData</code>并<code>SentGamePlayEventtoActor()</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UE4 Note</title>
      <link href="/UE4_note/"/>
      <url>/UE4_note/</url>
      
        <content type="html"><![CDATA[<ul><li>Charactor 中开启物理模拟(Simulate Physics)后会使Movement component失效</li></ul><h2 id="UE4-attach-调试流程"><a href="#UE4-attach-调试流程" class="headerlink" title="UE4 attach 调试流程"></a>UE4 attach 调试流程</h2><ol><li>VS IDE中选择的工程配置要和Editor中要一直，鼠标在UE Editor左上角项目名字悬停看弹出的配置信息，一般都是Development</li><li>VS中不用编译，直接attach到UE Editor</li><li>在UE Editor中点编译，多点几次，有时候代码可能会没有热更新上去</li><li>运行时就能命中VS中设置的断点了</li><li>如果还是无法命中代码，尝试在无法命中的地方随便修改下代码，然后再在UE编辑器里编译</li></ol><h2 id="C-读取蓝图类"><a href="#C-读取蓝图类" class="headerlink" title="C++ 读取蓝图类"></a>C++ 读取蓝图类</h2><ul><li>非静态加载</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GameplayAbilityBlueprint&#x27;/Game/Ability/MeleeBase_BP.MeleeBase_BP是在UE Editor中对对应蓝图类右键选择copy reference获得的，还需要强制加上 &quot;_C&quot;后缀</span></span><br><span class="line"><span class="keyword">auto</span> ability = LoadClass&lt;UGameplayAbility&gt;(<span class="literal">NULL</span>, <span class="built_in">TEXT</span>(<span class="string">&quot;GameplayAbilityBlueprint&#x27;/Game/Ability/MeleeBase_BP.MeleeBase_BP_C&#x27;&quot;</span>));</span><br></pre></td></tr></table></figure><h2 id="以C-为基类的蓝图类"><a href="#以C-为基类的蓝图类" class="headerlink" title="以C++为基类的蓝图类"></a>以C++为基类的蓝图类</h2><ul><li>当C++基类发生改变时，切记要把对应得蓝图子类切换下父类再切换回来才能应用到正确的数据</li></ul><h2 id="代码热更新问题"><a href="#代码热更新问题" class="headerlink" title="代码热更新问题"></a>代码热更新问题</h2><p>有很多类别都不能在C++代码编译后与立刻而更新到编辑器，比如Enum，函数返回参数等，在代码接口改变后，推荐关闭编辑器重新编译代码再打开</p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> UE4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在Qt的ModelIndex中增加数据擦除</title>
      <link href="/Qt_ModelIndex_typeerase/"/>
      <url>/Qt_ModelIndex_typeerase/</url>
      
        <content type="html"><![CDATA[<h2 id="Model-View-Framework"><a href="#Model-View-Framework" class="headerlink" title="Model/View Framework"></a>Model/View Framework</h2><p>Qt中的<code>QTableWidget</code>、<code>QListWidget</code>、<code>QTreeWidge</code>等背后都是一套常见的<code>Model/View</code>架构用户分离显示和数据。一般的自定义<code>View/Model</code>都可以通过继承<code>QAbstractItemView</code>和<code>QAbstractItemModel</code>来快速实现。</p><h2 id="ModelIndex"><a href="#ModelIndex" class="headerlink" title="ModelIndex"></a>ModelIndex</h2><p><code>View/Model</code>中通过<code>ModelIndex</code>来索引，<code>ModelIndex</code>中通过<code>row</code>、<code>col</code>和<code>internalPointer</code>来索引到具体的数据。能够适配到绝大分数据结构。<br>但是也存在很大的问题，就在于<code>internalPointer</code>的类型是一个<code>const void *</code>，会丢失原有类型信息，这就要求<code>internalPointer</code>指向统一中数据结构。但是很多时候是无法把要显示的数据的数据结构都做成同一个虚基类（比如是修改不了的不同的外部连接库的类）。<br>通过传入类型擦除后的数据结构的指针，或者建立一个map表来索引<code>internalPointer</code>到具体的类型信息可以解决一部分问题，但是还有一些致命的问题————无法自动释放<code>internalPointer</code>指向类型擦除数据结构或者即使的清空map表，随着时间的迁移，内存占用会越来越庞大，或者引入了非常复杂的自动释放机制。</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>解决的办法很简单，将<code>internalPointer</code>的类型从<code>const void *</code>替换为<code>QVariant</code>等即可，以<code>QVariant</code>储存类型擦除后的数据结构，不需要修改任何逻辑。<br>不过这样则需要复制下<code>QAbstractItemView</code>、<code>QAbstractItemModel</code>、<code>ModelIndex</code>的源代码，重新构建下应用<code>QVariant</code>的<code>ModelIndex</code>的<code>Model/View</code>框架。</p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Skia</title>
      <link href="/Compile_Skia/"/>
      <url>/Compile_Skia/</url>
      
        <content type="html"><![CDATA[<p><a href="https://skia.org/">Skia官方网站</a></p><h2 id="Window-10"><a href="#Window-10" class="headerlink" title="Window 10"></a>Window 10</h2><p>  Python 2.7.8<br>  Window 10 1909 (18363.1379)<br>  Window 10 SDK<br>  VS 2019<br>  LLVM 11.0.0</p><ul><li>准备Python2，并且设置Python2的优先级高于Python3(在环境变量里Python2的路径比Python3先出现即可)<br>否则会出现depot_tools错误和编译时ICU生成错误</li><li>拉取部署工具库<br><code>git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git</code></li><li>拉取Skia仓库<br><code>git clone https://skia.googlesource.com/skia.git</code></li><li>同步需要的第三方库<br><code>cd skia</code><br><code>python2 tools/git-sync-deps</code></li><li>设置VS路径<br>在 bn\BUILDCONFIG.gn 文件中，设置<br><code>win_vc = &lt;VS_Path&gt;</code> 如<br><code>win_vc = &quot;C:/Program Files (x86)/Microsoft Visual Studio/2019/Community/VC&quot;</code></li><li>生成编译文件<br>  Skia 编译成静态连接库中，会自动设置 Runtime 为 MT，需要手动设置为 MD<br>  Win 32位编译需要在输出文件夹中将 <code>toolchain.ninja</code> 中 <code>rule command</code> 中所有的<br>  <code>cmd.exe /c  C:/Program Files (x86)/Windows Kits/10/bin/SetEnv.cmd /x86 &amp;&amp;</code><br>  去掉，实际上既没有这个脚本，也不需要这个脚本<ul><li>win32 Debug 静态连接 /MDd Angle<br>  <code>bin\gn gen out/Debug --args=&quot;is_debug=true target_cpu=\&quot;x86\&quot; extra_cflags=[\&quot;/MDd\&quot;] clang_win=\&quot;C:/Program Files (x86)/LLVM\&quot; skia_use_angle = true&quot;</code></li><li>win32 Release 静态连接 /MD Angle<br>  <code>bin\gn gen out/Release --args=&quot;is_debug=false target_cpu=\&quot;x86\&quot; extra_cflags=[\&quot;/MD\&quot;] clang_win=\&quot;C:/Program Files (x86)/LLVM\&quot; skia_use_angle = true&quot;</code></li></ul></li><li>编译<br><code>ninja -C &lt;outpath&gt;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Skia </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译Qt</title>
      <link href="/Qt_compile/"/>
      <url>/Qt_compile/</url>
      
        <content type="html"><![CDATA[<h2 id="成功案例"><a href="#成功案例" class="headerlink" title="成功案例"></a>成功案例</h2><ul><li>Qt 6.0.1</li><li>Window 10 18363.1316 使用Unicode UTF-8提供全球语言支持</li><li>C/C++ Optimizing Compiler Version 19.28.29336 for x86</li><li>CMake version 3.19.4    <em><strong>CMake 需要大于3.18.3，否则输出Ninja工程文件时无法同时配置debug和release</strong></em></li><li>Python 3.9.1</li><li>ruby 2.7.2p137 (2020-10-01 revision 5445e04352) [x64-mingw32]</li><li>perl 5, version 32, subversion 1 (v5.32.1) built for MSWin32-x64-multi-thread</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:\Code\qsrc&gt;configure -opensource -confirm-license -prefix C:\Qt\6.0.1\msvc2019 -debug-and-release</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二维矩形排样/Rectangle Packing</title>
      <link href="/Rectangle_Packing_Algorithm/"/>
      <url>/Rectangle_Packing_Algorithm/</url>
      
        <content type="html"><![CDATA[<p><em><strong><u>现在的确是没时间研究。先把项目的进度推进了。记录研究过程回过头有时间再看看</u></strong></em></p><p>研究的起因在做图形引擎里的文字绘制功能，准备把字符纹理填充到一张、多张纹理，以减少drawcall。搜索了一番，发现事情并不简单，这个关于空间利用效率的算法有很多应用场所————计算机纹理打包，板材切割，集装箱打包货物等等。</p><p>简单的搜索了下，用中文基本没搜出啥有用的信息，用的关键字————矩形打包算法、排料算法<br>知网找了写有关的，比较新的论文看了下</p><ul><li><a href="https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&dbname=CJFDAUTO&filename=DYJE202012011&v=w1jssesbP2jiFm3%25mmd2BrHJJuxe5mFZEgs4YZnsboPjSMgzSr%25mmd2BTqlZ0H%25mmd2Fwwt51KVRCGg">曾晓亮,吴琼,袁旭华.二维矩形件排样问题的自适应多岛遗传算法优化[J].锻压技术,2020,45(12):53-58.</a><br><a href="%E4%BA%8C%E7%BB%B4%E7%9F%A9%E5%BD%A2%E4%BB%B6%E6%8E%92%E6%A0%B7%E9%97%AE%E9%A2%98%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%9A%E5%B2%9B%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96_%E6%9B%BE%E6%99%93%E4%BA%AE.pdf">直接下载</a></li></ul><p><em><strong><u>中文基本确定只有知网里没看过的文章值得再看看，搜索引擎的不用浪费时间</u></strong></em></p><p>英文搜索了下，关键字基本可以锁定在<code>packing</code>、<code>nesting</code>。先找了写有关的页面看了下</p><ul><li><a href="https://www.david-colson.com/2020/03/10/exploring-rect-packing.html">David Colson, Exploring rectangle packing algorithms</a><br> 这篇博文的作者的研究动机和我非常像，打包字符的纹理到同一张贴图中</li></ul><p><em><strong><u>英文的没怎么细看，随便搜搜看了下，有用的信息不少，可以花时间搜索细看</u></strong></em></p><h2 id="一步到胃"><a href="#一步到胃" class="headerlink" title="一步到胃"></a>一步到胃</h2><p>知名的C算法库<a href="https://github.com/nothings/stb">stb</a>/<code>stb_rect_pack.h</code>，无私奉献的公共领域许可。<br>看了下介绍，效果不太好。不过现在只需要一个大概能用的就行。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rectangle Packing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VS中正则表达式使用例子</title>
      <link href="/VS_regular_expression/"/>
      <url>/VS_regular_expression/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SetFlag\((?&lt;var&gt;.*),(?&lt;value&gt;.*)\)</span><br></pre></td></tr></table></figure><p>选择了SetFlag(A,B)中的并以${var}和${value}储存，值得注意的是，无嵌套能力，如果AB的表达式中有逗号，则不能正确的分组</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Regular Expression </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreeType中bitmap的buffer的数据顺序</title>
      <link href="/Freetype_bitmap_buffer_order/"/>
      <url>/Freetype_bitmap_buffer_order/</url>
      
        <content type="html"><![CDATA[<p>FreeType的bitmap中的数据顺序和屏幕坐标顺序一致，与OpenGL中texture的数据Y轴反转。第一个数据代表左上角，从左到右处理，最后一个数据代表右下角C++  </p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Freetype </tag>
            
            <tag> Bitmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL中Texture数据的顺序</title>
      <link href="/OpenGL_texture_data_order/"/>
      <url>/OpenGL_texture_data_order/</url>
      
        <content type="html"><![CDATA[<p>参考<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glTexImage2D.xhtml">OpenGL4 glTexImage2D</a></p><blockquote><p>The first element corresponds to the lower left corner of the texture image. Subsequent elements progress left-to-right through the remaining texels in the lowest row of the texture image, and then in successively higher rows of the texture image. The final element corresponds to the upper right corner of the texture image.</p></blockquote><p>buffer中第一个元素代表左下角，从左到右处理，最后一个元素代表右上角</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL ES </tag>
            
            <tag> OpenGL </tag>
            
            <tag> Texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glsl中texture采样的必需设置</title>
      <link href="/glsl_texture_setting/"/>
      <url>/glsl_texture_setting/</url>
      
        <content type="html"><![CDATA[<p>glsl中设置了贴图采样，代码中设置贴图一般需要以下步骤</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glGenTextures</span>(<span class="number">1</span>, &amp;texture);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="built_in">glTexImage2D</span>(...); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置环绕和过滤设置</span></span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);</span><br><span class="line"><span class="built_in">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动生成mipmap</span></span><br><span class="line"><span class="comment">//glGenerateMipmap(GL_TEXTURE_2D);</span></span><br></pre></td></tr></table></figure><p><code>mipmap</code>和<code>环绕过滤</code>设置至少要有一个，或者<code>glTexImage2D()</code>中设置了mipmap。按照经验，<code>OpenGL</code>，<code>OpenGL ES</code> 中均需要这样设置</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL ES </tag>
            
            <tag> GLSL </tag>
            
            <tag> OpenGL </tag>
            
            <tag> texture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GLES中attribute中默认位置</title>
      <link href="/GLES_attribute_default_location/"/>
      <url>/GLES_attribute_default_location/</url>
      
        <content type="html"><![CDATA[<p>gles程序遇到了一个在Windows 10 UHD630 下能正确运行却在 macOS 10.15.7 Iris 645却效果不对的问题。macOS下 OpenGL不能抓帧分析，经过了一番努力才发现了问题所在。</p><p>问题在于vertex shader中有好几个attribute, 在glVertexAttribPointer()按照了声明顺序默认了他们的索引。实际上 macOS 下attribute的默认顺序可能是倒过来了。使用了glGetAttribLocation()获取实际索引后，显示效果就正常了。</p><p>在GL3+的时候习惯了在vs中加上layout强制布局。在GLES中没有layout这回事，习惯性地沿用了以前做法，没想到真的出了问题</p>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL ES </tag>
            
            <tag> Attribute </tag>
            
            <tag> GLSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Qt实现多层布局</title>
      <link href="/Qt_Overlap_UI_with_Layout/"/>
      <url>/Qt_Overlap_UI_with_Layout/</url>
      
        <content type="html"><![CDATA[<h2 id="Question-问题"><a href="#Question-问题" class="headerlink" title="Question / 问题"></a>Question / 问题</h2><p>按照需求，需要在一些底层控件上叠加一些UI。比如底层是CAD的绘制页面或者视频播放页面，上面要放一些Label或者Button。上层需要添加的小空间往往不好直接加在最底层的控件上(底层已经有特殊的布局了)</p><h2 id="Search-研究过程"><a href="#Search-研究过程" class="headerlink" title="Search / 研究过程"></a>Search / 研究过程</h2><p>中英文都搜索了不少页面，大多是下面几种方法</p><ul><li>建立两个控件，最上层设置透明背景，属性设置<code>ToolTip</code>一类来实现<ul><li>属性设置的过程很复杂，先后顺序有特定要求</li><li>跨平台有问题</li></ul></li><li>利用<code>QGridLayout</code>布局，两个控件按先后顺序添加在同一个格子里</li><li>使用<code>QStackLayout</code>。</li><li>使用类似与Popup Menu的方法<ul><li><code>Popup</code>属性的窗口失去焦点后就会自动隐藏</li></ul></li></ul><p>除了特别列出来的问题，这些方法都有一个根本的问题————<u><strong>所有的消息都会被最上层的Widget拦截</strong></u>。例如鼠标指针跨过透明背景点击了底层的控件，消息仍会被最上层的控件拦截。  </p><ul><li>有些热心的开发者指出可以在最顶层的控件安装事件过滤器和转发器来实现消息可以合理的转发到底层。<ul><li>过滤和转发所有的事件会带来巨大的工作量，代码复用性几乎没有</li></ul></li><li>也可以通过直接添加上层控件到父窗口来实现————使用<code>setParent()</code>而不是<code>layout()-&gt;addWidget()</code>。<ul><li>没有布局功能，需要在父类实现<code>resizeEvent()</code>和<code>moveEvent()</code>的转发来手动计算布局</li><li>工作量也比较大，代码复用性也不好</li></ul></li></ul><h2 id="Solution-解决方案"><a href="#Solution-解决方案" class="headerlink" title="Solution / 解决方案"></a>Solution / 解决方案</h2><p>最后Qt的官方文档<a href="https://doc.qt.io/qt-6/layout.html">Layout Management</a>给了我启发。示例实现了个Qt没有自带而Java中有的布局<code>CardLayout</code></p><blockquote><p>The <code>CardLayout</code> class is inspired by the Java layout manager of the same name.</p></blockquote><p>其中设置子控件geometry部分的代码可以看到</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CardLayout::setGeometry</span><span class="params">(<span class="keyword">const</span> QRect &amp;r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QLayout::<span class="built_in">setGeometry</span>(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (m_items.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> w = r.<span class="built_in">width</span>() - (m_items.<span class="built_in">count</span>() - <span class="number">1</span>) * <span class="built_in">spacing</span>();</span><br><span class="line">    <span class="keyword">int</span> h = r.<span class="built_in">height</span>() - (m_items.<span class="built_in">count</span>() - <span class="number">1</span>) * <span class="built_in">spacing</span>();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; m_items.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        QLayoutItem *o = m_items.<span class="built_in">at</span>(i);</span><br><span class="line">        <span class="function">QRect <span class="title">geom</span><span class="params">(r.x() + i * spacing(), r.y() + i * spacing(), w, h)</span></span>;</span><br><span class="line">        o-&gt;<span class="built_in">setGeometry</span>(geom);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中最关键的一句是<code>o-&gt;setGeometry(geom);</code>。这表明<code>Layout</code>的本质是自动设置子控件的大小和位置。而我直接利用Qt原有的布局功能来计算每一层控件的大小和位置，再根据计算的结果来手动设置每个控件的大小的位置。不就能优雅地达到目的了吗。</p><p>实现起来比想象中的要更简单。先贴出代码<br><strong>OverlapLayout.h</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QLayout&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QList&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OverlapLayout</span> :</span> <span class="keyword">public</span> QLayout</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OverlapLayout</span>(QWidget* parent = <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">OverlapLayout</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// &lt;summary&gt;</span></span><br><span class="line">    <span class="comment">/// 新增的Item会转发到最后一层layout的addItem()</span></span><br><span class="line">    <span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line">    <span class="comment">/// &lt;param name=&quot;item&quot;&gt;&lt;/param&gt;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>         <span class="title">addItem</span><span class="params">(QLayoutItem* item)</span>     <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QSize        <span class="title">sizeHint</span><span class="params">()</span>               <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QSize        <span class="title">minimumSize</span><span class="params">()</span>            <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>          <span class="title">count</span><span class="params">()</span>                  <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QLayoutItem* <span class="title">itemAt</span><span class="params">(<span class="keyword">int</span>)</span>              <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function">QLayoutItem* <span class="title">takeAt</span><span class="params">(<span class="keyword">int</span>)</span>                    <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>         <span class="title">setGeometry</span><span class="params">(<span class="keyword">const</span> QRect&amp; rect)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AddLayout</span><span class="params">(QLayout*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QList&lt;QLayout*&gt; things;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>OverlapLayout.cpp</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;OverlapLayout.h&quot;</span><br><span class="line"></span><br><span class="line">#include &lt;QWidget&gt;</span><br><span class="line"></span><br><span class="line">OverlapLayout::OverlapLayout(QWidget* parent)</span><br><span class="line">    :QLayout(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OverlapLayout::addItem(QLayoutItem* item)</span><br><span class="line">&#123;</span><br><span class="line">    if(!things.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        things.last()-&gt;addItem(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSize OverlapLayout::sizeHint() const</span><br><span class="line">&#123;</span><br><span class="line">    QSize s(0, 0);</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        s = s.expandedTo(e-&gt;sizeHint());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QSize OverlapLayout::minimumSize() const</span><br><span class="line">&#123;</span><br><span class="line">    QSize s(0, 0);</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        s = s.expandedTo(e-&gt;minimumSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int OverlapLayout::count() const</span><br><span class="line">&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        num += e-&gt;count();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QLayoutItem* OverlapLayout::itemAt(int index) const</span><br><span class="line">&#123;</span><br><span class="line">    int num = 0;</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        next = num + e-&gt;count();</span><br><span class="line">        if (index &lt; next)</span><br><span class="line">        &#123;</span><br><span class="line">            return e-&gt;itemAt(index - num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QLayoutItem* OverlapLayout::takeAt(int index)</span><br><span class="line">&#123;</span><br><span class="line">    invalidate();</span><br><span class="line"></span><br><span class="line">    int num = 0;</span><br><span class="line">    int next = 0;</span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        next = num + e-&gt;count();</span><br><span class="line">        if (index &lt; next)</span><br><span class="line">        &#123;</span><br><span class="line">            e-&gt;invalidate();</span><br><span class="line">            return e-&gt;takeAt(index - num);</span><br><span class="line">        &#125;</span><br><span class="line">        num = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OverlapLayout::setGeometry(const QRect&amp; r)</span><br><span class="line">&#123;</span><br><span class="line">    if (things.size() == 0)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    for (auto e : things)</span><br><span class="line">    &#123;</span><br><span class="line">        e-&gt;invalidate();</span><br><span class="line">        e-&gt;setGeometry(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void OverlapLayout::AddLayout(QLayout* layout)</span><br><span class="line">&#123;</span><br><span class="line">    if(layout)</span><br><span class="line">    &#123;</span><br><span class="line">        invalidate();</span><br><span class="line">        things.append(layout);</span><br><span class="line">        addChildLayout(layout);</span><br><span class="line">        layout-&gt;invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现的思路也非常简单。储存多层<code>QLayout*</code>， 在<code>setGeometry()</code>中直接把整体的<code>QRect</code>传入到每一个层中计算就好。这样就可以优雅的使用添加多层布局和使用Qt中原有的功能。</p><h2 id="Usage-使用方法"><a href="#Usage-使用方法" class="headerlink" title="Usage / 使用方法"></a>Usage / 使用方法</h2><p>使用的方法也非常简单。父窗口的<code>layout</code>设置为<code>OverlapLayout</code>对象，把每一层的布局设置好，按顺序使用<code>OverlapLayout::AddLayout()</code>添加到多层布局里就好</p><h2 id="Doubts-疑点"><a href="#Doubts-疑点" class="headerlink" title="Doubts / 疑点"></a>Doubts / 疑点</h2><p>目前存在的一个疑问是————如何保证每一层的顺序呢。从官方例子中的<code>CardLayout::setGeometry</code>中看到的表现是，最后设置geometry的<code>QLayoutItem</code>在最上层，在<code>OverlapLayout</code>实际体验中也是如此表现，但是目前还不确定一定会如此</p><p>使用中发现和层序有关的问题，在<code>QScrollBar</code>第一次触发hover事件的时候，<code>QScrollBar</code>会提到最上面刷新一下，又回到原来的层次，但是有些控件会被挡住。触发下被挡住的控件将恢复正常，且不再出现异常</p><h2 id="Update-1-更新1"><a href="#Update-1-更新1" class="headerlink" title="Update 1 / 更新1"></a>Update 1 / 更新1</h2><p>在使用中发现了控件改变后不能做出有效更新的问题。翻看了<code>QBoxLayout</code>等的源代码后发现里面多处使用到了<code>invalidate()</code>来标记重新计算布局。在源代码中增加其调用后表现正常</p>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不要在Markdown中进行缩进排版</title>
      <link href="/Markdown_use_hint/"/>
      <url>/Markdown_use_hint/</url>
      
        <content type="html"><![CDATA[<p>Markdown 中没有排版的概念，所有不要试图花费大力气去进行缩进等排版。各个Markdown渲染对缩进表达各不相同。</p>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pelican 使用笔记</title>
      <link href="/pelican_use_hint/"/>
      <url>/pelican_use_hint/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.getpelican.com/en/4.5.3/quickstart.html">Pelican官方文档</a></p><ul><li><p>Version：4.5.3</p></li><li><p>python：3.6+</p><p><em>以下命令目录均在Pelican工程目录下</em></p></li><li><p>带主题输出</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pelican content -s pelicanconf.py -t /projects/your-site/themes/our-theme</span></span><br><span class="line">pelican content -s pelicanconf.py -t ./theme</span><br></pre></td></tr></table></figure><ul><li>带主题，忽略缓存和自动重载，监听</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> pelican -l -t THEME --ignore-cache -r</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> THEME指的是主题模板所在</span></span><br><span class="line">pelican -l -t ./theme --ignore-cache -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在edge中需要删除本地缓存才能刷新主题</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> Pelican </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL drawcall 边界越界问题</title>
      <link href="/OpenGL_drawcall_out_of_range/"/>
      <url>/OpenGL_drawcall_out_of_range/</url>
      
        <content type="html"><![CDATA[<h2 id="buffer数据时size的大小"><a href="#buffer数据时size的大小" class="headerlink" title="buffer数据时size的大小"></a>buffer数据时size的大小</h2><p>在 OpenGL buffer数据一般都是以const void *加size的C语言风格传递数据。例如下面非常经典的<br><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glBufferData.xhtml">void glBufferData( GLenum target, GLsizeiptr size, const void * data, GLenum usage)</a><br>有下面用法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据来源</span></span><br><span class="line">std::vector&lt;<span class="keyword">float</span>&gt; dataContainer &#123;···&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 也就是 dataContainer.size() * sizeof (float)</span></span><br><span class="line">GLsizeiptr size = dataContainer.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">decltype</span> (dataContainer)::value_type);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>* data = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(dataContainer.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure><p>可以看到，这里的<code>size</code>是以字节为单位，而且<code>size</code>的类型为 <code>GLsizeiptr</code> 。</p><h2 id="drawcall时count的大小"><a href="#drawcall时count的大小" class="headerlink" title="drawcall时count的大小"></a>drawcall时count的大小</h2><p>同样是非常经典的<br><a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml">void glDrawArrays( GLenum mode, GLint first, GLsizei count);</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">float</span>&gt; dataContainer &#123;···&#125;;</span><br><span class="line">GLsizeiptr size = dataContainer.<span class="built_in">size</span>() * <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">decltype</span> (dataContainer)::value_type);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">void</span>* data = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;(dataContainer.<span class="built_in">data</span>());</span><br><span class="line"></span><br><span class="line">GLuint vbo;</span><br><span class="line"><span class="built_in">glGenBuffers</span>(<span class="number">1</span>, &amp;vbo);</span><br><span class="line"><span class="built_in">glBindBuffer</span>(GL_ARRAY_BUFFER, vbo);</span><br><span class="line"><span class="built_in">glBufferData</span>(GL_ARRAY_BUFFER, size, data, GL_STATIC_DRAW);</span><br><span class="line"><span class="built_in">glVertexAttribPointer</span>(<span class="number">0</span>, <span class="number">2</span>, GL_FLOAT, GL_FALSE, <span class="number">2</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(GLfloat), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GLsizei counts = size / (<span class="number">2</span>*<span class="built_in"><span class="keyword">sizeof</span></span>(GLfloat));</span><br><span class="line"><span class="built_in">glDrawArrays</span>(GL_LINES, <span class="number">0</span>, counts);</span><br></pre></td></tr></table></figure><p>此时count中每一个的大小是由<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glVertexAttribPointer.xhtml">glVertexAttribPointer</a>中的<code>size</code>，<code>type</code>和<code>stride</code>共同决定。如上例中，一个点的大小就是<code>2</code>个<code>float</code>的大小。要绘制完buffer中的所有内容需要<code>size / (2*sizeof(GLfloat))</code>。</p><h2 id="drawcall超出边界时会发生情况"><a href="#drawcall超出边界时会发生情况" class="headerlink" title="drawcall超出边界时会发生情况"></a>drawcall超出边界时会发生情况</h2><p>数组越界是一个比较常见的错误。有些语言会直接抛出异常，如C/C++，有些语言则会直接访问到对应的内容，返回不确定的结果。在OpenGL里，drawcall中的越界——如<code>glDrawArrays()</code>中的<code>first</code>和<code>counts</code>指向的显存段超过当前绑定的vbo则是未定义的行为。（至少我在<a href="https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/glDrawArrays.xhtml">OpenGL-Refpages</a>中没看到对应的规范）<br>实际上在具体应用中，同样的越界drawcall在不同显卡和操作系统表现出来的行为也是不一样。应该是由显卡驱动厂商决定越界行为的。</p><ul><li><p>macOS OpenGL ES2.0 Intel Iris Plus 645<br>在macOS下，drawcall越界了后，越界的部分的内存的默认值通常是0，在显存使用量不高的情况下，通常不会绘制出奇怪的内容。也不会引发OpenGL错误。这和Apple下Clang编译器的行为也一致，变量默认值为0</p></li><li><p>Windows OpenGL ES2.0 Intel UHD 630<br>在Windows下drawcall越界同样也不会引发OpenGL错误，但是很容易绘制出奇怪的东西出来。</p></li><li><p><em><strong>Windows Angle</strong></em></p></li><li><p><strong>Windows下使用Angle转译glES到Dx值得特别提一下。使用Angle时，如果drawcall越界了，则会直接跳过，什么效果都没有。用RenderDoc截取帧分析会找不到越界的drawcall，显示上也没有效果。推测可能时Dx引发错误或者Angel内部记录到会有越界行为发生。</strong>*</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Computer Graphics </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
            <tag> drawcall </tag>
            
            <tag> out of range </tag>
            
            <tag> Angel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QToolBar增加spacer</title>
      <link href="/QToolBar_add_spacer/"/>
      <url>/QToolBar_add_spacer/</url>
      
        <content type="html"><![CDATA[<p>通过一个空的QWidget设置SizePolicy来代替QSpacerItem</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">QWidget* spacer = <span class="keyword">new</span> <span class="built_in">QWidget</span>();</span><br><span class="line">spacer-&gt;<span class="built_in">setSizePolicy</span>(QSizePolicy::Expanding, SizePolicy::Expanding);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> tb = <span class="keyword">new</span> QToolBar;</span><br><span class="line">...</span><br><span class="line">tb-&gt;<span class="built_in">addAction</span>(...);</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">tb-&gt;<span class="built_in">addWidget</span>(spacer);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">tb-&gt;<span class="built_in">addAction</span>(...);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Programing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> Qt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
